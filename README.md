# Транслятор

Необходимо реализовать транслятор, который будет включать в себя 4 модуля:

- лексический анализатор
- синтаксический анализатор
- семантический анализатор
- генератор кода

Требования к программе:

- Развертываемость (docker, поднятый инстанс сайта, универсальный код + скрипт для запуска программы и т.д.)
- Unit тесты для каждого модуля, можно воспользоваться TDD
- Исходный код опубликовать на github
- Человеко-понятные ошибки

## Лексический анализатор

Что делает: парсит исходную программу на слова (токены).\
Вход: исходный код программы.\
Выход: массив токенов.

Токен имеет примерно следующую структуру данных:

```json
{
    "лексема": {
        "код лексемы": string|int,
        "значение лексемы": string|int
    },
    "номер строки": int,
    "номер столбца": int
}
```

Что не должен делать лексер?

Проверять синтаксис входного языка программирования. За проверку синтаксиса отвечает синтаксический анализатор.

Существует, как минимум 3 подхода к реализации лексера:

1) Конечный автомат
2) Регексы
3) if-чики

## Синтаксический анализатор

Что делает: проверяет синтаксис языка.\
Вход: массив токенов.\
Выход: дерево разбора (или AST).

Понадобится грамматика с прошлого семестра. Возможно, необходимо будет доработать.
Структура для грамматики любая (например, можно задавать грамматику в виде массива).

Алгоритмы для реализации синтаксического анализатора:

1) Алгоритм Эрли. Есть подводные с получением дерева разбора (см. `earley.pdf`).
2) LL1-грамматика
3) Восходящий-нисходящий разбор
4) Алгоритм Кока — Янгера — Касами
5) ...

## Семантический анализатор

Что делает: проверяет семантику языка программирования.\
Вход: дерево разбора (либо какое-нибудь промежуточное представление).\
Выход: дерево разбора (либо какое-нибудь промежуточное представление).

Если по простому, то семантический анализатор проверяет:

- области видимости
- объявлена ли переменная/функция
- вызов функции с ее сигнатурой
- типизацию
- лимиты (максимальную вложенность скобок, максимальную длину строки и т.д.)

Реализовывается путем обхода дерева и if-чиков.

## Генератор кода

Что делает: генерирует код конечной программы.\
Вход: дерево разбора (либо какое-нибудь промежуточное представление)\
Выход: конечный код программы.

Дерево разматывается в конечный код программы на новом языке на основе таблицы преобразований.

## Обработка ошибок

1) Завершение программы на первой ошибке.
2) Востановление работы после первой ошибки. В конце модуля программа все равно завершится с ошибкой. Такой подход позволит вывести весь список ошибок.
